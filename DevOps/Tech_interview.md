
<details>
<summary>Linux</summary>
Hard link vs soft link
A hard link is a file all its own, and the file references or points to the exact spot on a hard drive where the Inode stores the data.
A soft link isn't a separate file, it points to the name of the original file, rather than to a spot on the hard drive.

а) Жесткая ссылка не может быть создана для каталогов. Жесткая ссылка может быть создана только для файла.
б) Символические ссылки или симлинки могут ссылаться на каталог.

что в Линукс отвечает за открытие файлов?

Inode
inode  или индексный дескриптор — это структура данных в которой хранится метаинформация о стандартных файлах, каталогах или других объектах файловой системы, кроме непосредственно данных и имени.
Ну то есть , грубо говоря, что на 1 файл или директорию тратится 1 inode
На случай если кончились inode, заклинаний не подскажу. Так что для разделов в которы плодятся мелкие файлы следует грамотно выбирать файловую систему или нпйти и удалить все мелкие нулевые файлы.
Пример, мы как-то давно использовали btrfs для хранения множества мелких файлов тк в ней inode создаются динамически
Поискать нулевые файлы



Как узнать оболочку линукс?
echo $0

Что такое образ initrd?

Начальный RAM-диск (initrd) – это исходная корневая файловая система, которая монтируется до того, как будет доступна настоящая корневая файловая система.
Initrd привязан к ядру и загружен как часть процедуры загрузки ядра.

SUID SGID Sticky bit
SUID: если установлен бит setuid, когда файл выполняется пользователем, процесс будет иметь те же права, что и владелец исполняемого файла.
SGID: То же  самое что SUID, но только для групп
Sticky bit:  в основном это касается папок, подразумевает, файл или папка, созданные в папке с поддержкой stickybit, могут быть удалены только владельцем. Например , исползование sticky-бита – это /tmp, где каждый пользователь имеет разрешение на запись, но удалить его могут только пользователи, владеющие файлом.

Состояния процессов

```
Running (R):
Процесс либо выполняется на процессоре, либо готов к выполнению (ожидает своей очереди).

Sleeping (S или D):
Interruptible sleep (S): Процесс спит (ожидает завершения какого-либо события, например, ввода-вывода) и может быть прерван сигналом.
Uninterruptible sleep (D): Процесс находится в состоянии сна и не может быть прерван сигналом. Обычно это состояние связано с ожиданием завершения операций ввода-вывода.

Stopped (T):
Процесс остановлен, обычно сигналом (например, SIGSTOP или SIGTSTP), и ожидает дальнейших инструкций. Процесс может быть возобновлен с помощью сигнала SIGCONT.

Zombie (Z):
Процесс завершил выполнение, но его запись в таблице процессов ещё не удалена, так как родительский процесс ещё не вызвал wait() для получения статуса завершения. Это состояние временно и длится до того, как родительский процесс обработает завершение дочернего процесса.

Traced (t):
Процесс находится под контролем отладчика (например, gdb).

Idle (I):
В некоторых версиях ядра или инструментов мониторинга может присутствовать это состояние, обозначающее, что процесс ничего не делает, но при этом не находится в ожидании, как в Sleeping.
```

Что такое zombie процесс?
В Linux (и других Unix-подобных операционных системах) процесс-зомби (zombie process) — это процесс, который завершил своё выполнение, но его запись в таблице процессов всё ещё сохраняется. Это происходит, когда процесс завершает своё выполнение, но его родительский процесс не вызвал системный вызов wait() для получения кода завершения дочернего процесса.

Основные системные вызовы:
```
- open - открыть файл
- read - пытается читать из файлового дискриптора
- write - пытается записать в файловый дескриптор
- close - закрывает файл посмле чтения илм записи
- fork - создает новый дочерний процесс
- execve - выполняет исплняемый файл
- kill
```

Что такое уровни запуска в linux и как их изменить?

Уровень выполнения – это состояние init и всей системы, которое определяет, какие системные службы работают, и они идентифицируются по номерам.

Существует 7 различных уровней выполнения (уровень выполнения 0-6) в системе Linux для различных целей.

Описания приведены ниже.

```
0: Halt System (To shutdown the system)
1: Single user mode
2: Basic multi user mode without NFS
3: Full multi user mode (text based)
4: unused
5: Multi user mode with Graphical User Interface
6: Reboot System
```

Команда TOP
RES (Resident Set Size): Это объем физической памяти (RAM), который используется процессом в данный момент. Включает: Текущие разделяемые библиотеки, а также физическую память, занятую процессом.

VIRT (Virtual Memory Size): Что показывает: Это общий объем виртуальной памяти, используемой процессом. Включает: Все кодовые, данные и разделяемые библиотеки, а также память, выделенную, но не использованную (т.е. не загруженную в RAM).


42. Что такое SeLinux?


SELinux – это аббревиатура от Security-enhanced Linux.

Это реализация контроля доступа и функция безопасности для ядра Linux.
Он предназначен для защиты сервера от неправильной настройки и / или скомпрометированных демонов.

Он устанавливает ограничения и инструктирует серверные демоны или программы, к каким файлам они могут обращаться и какие действия они могут предпринимать, определяя политику безопасности.


44. В чем разница между виртуальным хостингом на основе имени и виртуальным хостингом на основе IP?

Виртуальные хосты используются для размещения нескольких доменов на одном экземпляре Apache/Nginx.

Вы можете иметь один виртуальный хост для каждого IP-адреса вашего сервера, или один и тот же IP-адрес, но разные порты, или один и тот же IP-адрес, один и тот же порт, но разные имена хостов.
Последнее называется «ame based vhosts».
На виртуальном хостинге на основе IP мы можем запустить более одного веб-сайта на одном сервере, но каждый веб-сайт имеет свой IP-адрес, в то время как в виртуальном хостинге на основе имен мы размещаем несколько веб-сайтов на одном IP-адресе.
Но для этого вам нужно поместить более одной записи DNS для вашего IP-адреса в базу данных DNS.



Какое использование файлов /etc/passwd и /etc/shadow?

Файл /etc/shadow хранит действительный пароль в зашифрованном формате с некоторыми дополнительными свойствами, связанными с паролем пользователя.
В основном он учитывает параметры старения. Все поля разделены двоеточием (:).

Он содержит одну запись на строку для каждого пользователя, указанного в файле /etc/pass


Зачем устанавливать безпарольный вход по ssh?

Чтобы еще больше повысить безопасность системы, большинство организаций решили использовать аутентификацию на основе ключей вместо аутентификации на основе пароля.
Мы можем обеспечить аутентификацию на основе ключей, отключив стандартную аутентификацию по паролю.
Открытый ключ добавляется в файл конфигурации сервера, в то время как личный ключ остается конфиденциальным на стороне клиента.


Что такое swappiness в Linux?

Параметр swappiness контролирует стремление ядра перемещать процессы из физической памяти на диск подкачки.


OMM killer -защитный механизм ядра Linux, призванный решать проблемы с нехваткой памяти. При исчерпании доступной памяти он принудительно «убивает» наиболее подходящий по приоритетам процесс, отправляя ему сигнал KILL

Garbage collector - одна из форм автоматического управления памятью. Специальный процесс, называемый сборщиком мусора (англ. garbage collector), периодически освобождает память, удаляя из неё ставшие ненужными объекты.

Load average — это показатель, который используется для отображения средней нагрузки на систему за определенные периоды времени. Он указывает на количество активных процессов, которые либо выполняются, либо ожидают выполнения на процессоре.

</details>

<details>
<summary>Docker</summary>

Отличие docker  от  VM
В основе VM гипервизор,
Под капотом докера Namespaces + Control groups

namespaces для организации изолированных рабочих пространств, которые мы называем контейнерами.
Список некоторых пространств имен, которые использует docker:

- pid: для изоляции процесса;
- net: для управления сетевыми интерфейсами;
- ipc: для управления IPC ресурсами. (ICP: InterProccess Communication);
- mnt: для управления точками монтирования;
- utc: для изолирования ядра и контроля генерации версий(UTC: Unix timesharing system)


Control groups (контрольные группы)

cgroups для распределение или ограничения ресурсов для  процессов (процессорные, сетевые, ресурсы памяти, ресурсы ввода-вывода)

CMD ENTRYPOINT RUN
CMD sets the command and its parameters to be executed by default after the container is started. However, CMD can be replaced by docker run command line parameters. ENTRYPOINT configures the command to run when the container starts

Инструкции dockerfile:
FROM
ENV
ARG
WORKDIR
RUN
EXPOSE - Никакие порты не открываются, это элемент документирования
VOLUME - внутри контейнера становится томом. При запуске контейнера Docker автоматически создаст том и примонтирует его к этому пути. Данные, записанные в том(volume), сохранятся даже после остановки или удаления контейнера. Например,VOLUME /data.

CMD  явлется как бы дополнением   ENTRYPOINT
те в Entrypoint мы кладем команду ( python server.py),  а в CMD мы кладем  аргуметы к комманде
 Если посмотреть чуть шире, а именно в разрезе  k8s , то  Entrypoint  у нас был зашит в образ, а CMD  мы мы передовали через helm  в зависимости от среды ( dev/qa/stg)  через параметр args

k8s command -> entrypoint
k8s args ->  cmd


Минимизация количества слоев образа


При использовании таких команд, как RUN, COPY, ADD Docker создает слои. Каждый слой увеличивает размер образа, так как слои кэшируются.
Чтобы уменьшить количество слоев, необходимо объединять (комбинировать) команды в цепочки для того, чтобы исключить проблемы, связанные с неправильным использованием кэша. Рассмотрим эти рекомендации на конкретных примерах. Предположим, нам необходимо выполнить следующие 2 команды:
```
RUN apt update
RUN apt -y install tree
```
Если вы используете apt, необходимо комбинировать в одной инструкции RUN команды apt update и apt install. Команды выше необходимо скомбинировать в одну команду следующим методом:
```
RUN apt update && apt -y install tree
```
В результате вместо двух слоев будет создан один слой, и как итог будет уменьшен размер финального образа. Кроме того, следует объединять в одну инструкцию команды установки пакетов. Перечислять пакеты необходимо на нескольких строках, разделяя список символами \. Выглядеть это может так:
```
RUN apt update && apt install -y \
	htop \
	tree \
	mc
```
Этот метод также позволяет сократить число слоёв, которые должны быть добавлены в образ, и помогает поддерживать код файла в читаемом виде.

Удаление кэшей и временных файлов

При использовании пакетных менеджеров, таких как apt, apk, yum/dnf, они кэшируют загружаемые данные с целью снижения нагрузки на сеть, и, как следствие, уменьшается время, требуемое для установки программ. Данный кэш необходимо удалять, чтобы размер итогового образа не разрастался до больших объемов.
Для удаления кэша в конец команды по установке (например, apt install) необходимо добавить одну из нижеперечисленных строк — в зависимости от используемого пакетного менеджера:
```
APT: ... && rm -rf /var/cache/apt
APK: ... && rm -rf /etc/apk/cache
YUM: ... && rm -rf /var/cache/yum
DNF: ... && rm -rf /var/cache/dnf
```

Cетевые драйверы docker
несколько драйверов по умолчанию, которые обеспечивают основной функционал по работе с сетью:
- none: отключение всех сетевых ресурсов.
- bridge: сетевой драйвер по умолчанию. По сути, это мост между контейнером и хостовой машиной. Мостовые сети обычно используются, когда приложения выполняются в автономных контейнерах, которые должны взаимодействовать друг с другом.
- host: для автономных контейнеров устраняется сетевая изолированность между контейнером и хостом Docker и напрямую используются сетевые ресурсы хоста.
- overlay: наложенные сети соединяют несколько демонов Docker.
- macvlan: сети Macvlan позволяют присваивать контейнеру MAC-адрес, благодаря чему он выглядит как физическое устройство в сети.

Docker многостадийная сборка (multi-stage build) — это методика сборки образов Docker, которая позволяет создавать более легкие и оптимизированные образы с помощью нескольких этапов сборки в одном Dockerfile. Это особенно полезно для создания минимальных продакшн образов, содержащих только необходимое программное обеспечение и зависимости, без лишних файлов, которые были нужны только на этапе сборки или тестирования.

</details>

<details>
<summary>Kubernetes</summary>

Компоненты:

Kube-api - предоставляет kubernets API
ETCD - Хранит все данные о состоянии кластера (конфигурация, секреты, статусы и т.п.).
Sheduler - разпрелеляет приложения, назначает рабочий узел каждому приложению
kube-controller-manager -
Управляет контроллерами (controllers), которые следят за текущим состоянием кластера и стремятся к желаемому состоянию.
Примеры:
	ReplicaSet Controller — гарантирует нужное количество реплик Pod'ов.
	Node Controller — следит за состоянием узлов.
	Deployment Controller — управляет обновлениями приложений.

kubelet
Агент, который получает инструкции от API Server и управляет контейнерами на узле.


kube-proxy
kube-proxy — сетевой прокси, работающий на каждом узле в кластере, и реализующий часть концепции сервис.


IRSA (AWS only) - this option creates an identity provider for the cluster.
After this step we can add role and policy on the side of Amazon cloud, I mean IAM service.
Add the identity number of this role to the k8s service account as annotation and assign this service account to the appropriate pod or deployment.

Role —  который описывает некий набор прав на объекты кластера Kubernetes. Role ничего и никому не разрешает. Это просто список.
RoleBinding -
ServiceAccount -
Пример: kubectl auth can-i get pods --as <serviceaccount> -n <namespace>

1. Liveness Probe используется для определения необходимости перезапуска контейнера.
2. Readiness Probe используется для определения готовности контейнера принимать трафик, ну то есть когда пускать/не пускать трафик.
3. Startup Probe используется для проверки успешного завершения инициализации контейнера и позволяет игнорировать liveness и readiness проверки до её завершения.

Pod Disruption Budget (PDB)
```
это механизм в Kubernetes, который помогает управлять количеством pod'ов (единиц приложения) в кластере, которые могут быть одновременно остановлены или перезапущены. PDB гарантирует, что определенное количество pod'ов останется доступным даже в случае непредвиденных сбоев или плановых обновлений.
```
QoS (Quality of Service) class
```
метрика определяющая приоритет пода (Pod) в кластере на основе его потребностей в ресурсах (CPU и памяти).
Guaranteed (Гарантированный) -  самый высокий приоритет (request == limits)
Burstable (Гибкий) - Они более гибки, чем Guaranteed, и их могут удалить раньше (requests < limits)
Best-Effort (Лучший вариант) - (Ни requests, ни limits) поды будут удалены первыми при нехватке ресурсов.
```

NodeSelector - юнит в описании манифеста, который служит для выбора нод под запуск подов ( например нода для запуска с меткой GPU)
Affinity - используется для размещение подов на соответствущих описанным критериям нодах при определнных условиях.( например запускать поды из данного деплоймента на нодах из определенной availibility zone,  instance type, etc)
AnitAffinity -  для обратного вышеописанному
taint -   для того чтобы запретить подам быть запущенным на определнных нодах. Использается при описании  NodeGroup(Ноды)

Чтобы поды от деплоймента в Kubernetes распределялись на разные ноды, а не на одну, можно воспользоваться несколькими подходами:

 Использование PodAntiAffinity

PodAntiAffinity позволяет указывать, что поды не должны размещаться на одной и той же ноде. Это настраивается с помощью полей affinity и podAntiAffinity в манифесте деплоймента.

Как работает OOM Killer в Kubernetes
```
Лимиты и запросы памяти:

В Kubernetes ресурсы, такие как память и CPU, управляются с помощью параметров requests и limits, которые можно задавать в манифесте контейнера.
requests — это минимальное количество ресурсов, которое гарантированно выделяется контейнеру.
limits — это максимальное количество ресурсов, которое контейнер может использовать.
Переполнение лимитов памяти:

Если контейнер начинает использовать больше памяти, чем указано в limits, ядро Linux может сработать и активировать OOM Killer.
Когда OOM Killer активируется, он завершает процессы, чтобы освободить память. В контексте контейнеров это означает завершение всего контейнера.
Выбор процесса для завершения:

OOM Killer выбирает процессы для завершения на основе их "oom_score", который рассчитывается ядром на основании различных факторов, таких как размер процесса, время его выполнения и важность.
Контейнеры, которые потребляют больше памяти, чем указано в limits, получают повышенный "oom_score" и, следовательно, становятся приоритетными кандидатами для завершения.
Последствия в Kubernetes:

Когда контейнер убивается OOM Killer-ом, Kubernetes помечает этот контейнер как OOMKilled и может попытаться перезапустить его, в зависимости от настроек restartPolicy.
Если контейнер постоянно превышает лимит памяти и OOM Killer регулярно его завершает, это может привести к циклическим перезапускам (crash loop).
События и диагностика:

Kubernetes генерирует событие, указывающее, что контейнер был завершен из-за превышения лимита памяти (событие типа OOMKilled).
Для диагностики можно просмотреть логи пода и события с помощью команд kubectl logs и kubectl describe pod.
Профилактика:

Чтобы избежать ситуаций с OOM Killer, рекомендуется правильно рассчитывать requests и limits для контейнеров на основе профилирования и мониторинга приложения.
Можно также использовать инструменты мониторинга, такие как Prometheus, для наблюдения за потреблением памяти и другими метриками в кластере.
Таким образом, OOM Killer играет важную роль в управлении памятью и обеспечении стабильности узлов в Kubernetes, но требует внимательной настройки ресурсов для контейнеров, чтобы избежать нежелательных завершений и перезапусков.
```

В Kubernetes LimitRange и ResourceQuota — это механизмы, которые позволяют ограничивать использование ресурсов (CPU, память) в namespace'ах , чтобы предотвратить чрезмерное потребление ресурсов и обеспечить стабильность кластера.

LimitRange - Ограничивает минимальные и максимальные значения requests и limits на уровне отдельного контейнера или Pod'а внутри namespace.

ResourceQuota - Ограничивает общее использование ресурсов в namespace . То есть, сколько всего может быть выделено ресурсов всем Pod'ам в рамках одного namespace.

**Questions**
-  Какие вопросы вы зададите разработчику, когда он приносит код для деплоя в Kubernetes?
- Какие kubernetes-объекты используете для деплоя stateful приложения?
- Как диагностировать задержки между двумя кластерами с раздельными БД и приложениями? 
	```sh
	У каждого приложения есть своя база ранных. Эти приложенияя общаются через интеренет по https.  
	С первого кластера приложение отправляяет во второе приложение, там приложение записывает в базу,  
	отсылает ответ и первый записывает в свою базу, Этот раунд длятся 400 милисекунд, но бывают задержки 3 секунды.  
	Куда смотреть? 
	```
- Какие ресурсы проверяете на хосте для обеспечения надёжной работы БД?
- Какие шаги предпримете при оптимизации БД, например Postgres?
- Как анализируете сетевые проблемы между двумя кластерами?

</details>

<details>
<summary>Terraform</summary>

Что такое стейт файл, что в нем хранится, можно ли править руками? Что такое и зачем нужен лок?
стейт файл - файл состояния, в котором хранится описание созданных ресурсов. Руками править можно, но лучше вносить правки через terraform import.
Lock file служит для сохранения хэшей версий провайдеров и модулей

Что такое null ресурс?
null_resource является ресурсом , который позволяет настроить provisioners, которые непосредственно не связаны с одним существующим ресурсом.

</details>


<details>
<summary>AWS</summary>


AWS System manager - is a secure end-to-end management solution for resources on AWS and in multi-cloud and hybrid environments

Availability zone

VPC -

nat gateway -

internet gateway -

Security groups - firewall at the instance level
acts as a firewall that controls the traffic allowed to and from the resources in your virtual private cloud (VPC). You can choose the ports and protocols to allow for inbound traffic and for outbound traffic.
- Security groups are stateful. For example, if you send a request from an instance, the response traffic for that request is allowed to reach the instance regardless of the inbound security group rules. Responses to allowed inbound traffic are allowed to leave the instance, regardless of the outbound rules.


network ACL  - Список управления доступом к сети (ACL) разрешает или запрещает определенный входящий или исходящий трафик на уровне подсети.
	Default network ACL - allows all inbound traffic
	Custom network ACL - denies all inbound and outbound traffic untill you add rules
	Block specific IP addresses^ not security group

Site-to-Site VPN -  connection between remote devices and AWS resources. Virtual Private Gateway --> IPSEC --> Customer gateway (on-premise network)
Network ACLs are stateless, which means that return traffic must be explicitly allowed by the rules.

Direct connect - directly connect to AWS data center without internet

AWS Private link - Establish connectivity between VPCs and AWS services without exposing data to the internet

Athena -  серви запросов, похожий на SQL

Amazon OpenSearch Service makes it easy for you to perform interactive log analytics,

VPC Flow logs - Опция для логирования сетевого трафика

CloudFront- system of distributed servers that deliver webpages and other web content

Application Load Balancer принимает решения о маршрутизации на уровне приложения (HTTP/HTTPS), поддерживает маршрутизацию на основе пути и может направлять запросы на один или несколько портов в каждом экземпляре контейнера в вашем кластере.

Network Load Balancer  принимает решения о маршрутизации на транспортном уровне (TCP/SSL). Он может обрабатывать миллионы запросов в секунду. После того, как балансировщик нагрузки получает соединение, он выбирает цель из целевой группы для правила по умолчанию, используя алгоритм маршрутизации хеширования потока. Он пытается открыть TCP-соединение с выбранной целью на порту, указанном в конфигурации прослушивателя. Он пересылает запрос без изменения заголовков.

Route53
	Simple - Rote traffic to a single resource
	Failover - Active-passive failover
	Geolocation - Route traffic based on the location
	Geoproximity - Based on the physical distance between your users and your resources
	Latency based - Route traffic based on the based latency to provide good performance
	Multivalue Answers - Enable Route53 to respond with up to end to eight selected at random (Round-robin)
	Weighted - Route traffic to multiple resources based on a numerical weight
---
VPC
VPC -->  add subnets --> create Rote table --> create NACL --> associate subnets with route tables

VPC endpoint with accaes to S3
Launch EC2 --> Create Vpc endpoint for S3 --> Review route table

S3
Standard - >= 3 AZs    99.9 % (For workloads and frequent data)
Standard infrequent access -  >= 3 AZ Long-term infriquent accessed critical data
One Zone Infrequent access - 1 AZ Long term infriquent access, non-critical
Glacier Instant Retrieval - >=3 AZ Long live data. For infrequent data (Minimum duration 90 days)
Glacier Flexible Retrieval >=3 AZ Long-term data archiving needs to be accessed within a few hours or minutes
Glacier deep archive - >=3 AZ Rerely accessed data archiving. default retrieval time 12 hours (Minimum duration 180 days)
S3 Intelligent-tiering - >=3 AZ Unknown or unpredictable access pattern

Server-side encryption:
	SSE-S3 - S3 managed keys AES 256-bit encryption
	SSE-KMS - AWS Key Management Service managed keys
	SSE-C - Customer-provided keys

S3 Static website
	Enable static website -> Disable Block Public Access settings -> Allow public read access for your objects

Inventory bucket - Used to help understand how you are storing objects in S3 bucket

EFS storage classes:


AWS Config continually assesses, audits, and evaluates the configurations and relationships of your resources on AWS,

File gateway - Access files stored on S3 using NFS or SMB
Fsx Gateway - Access files in Amazon Fsx for Windows File Server using SMB
Volume gateway(Stored Mode) - Your entire dataset is stored on-site and backend up to S3 as RBS snapshots.
Volume Gateway (Cached mode) - Your entire dataset is stored in S3 (only frequently accessed)


1 subnet in 1 availability zone

security group - фильтрует трафик на уровне инстанса
NACL - фильтркет трафик на уровне подсети
</details>




<details>
<summary>Виды тестов</summary>
виды тестов:
Юнит-тестирование (Unit Testing):
Тестирование отдельных компонентов или модулей приложения изолированно.
Цель: проверить, что каждый модуль работает правильно.

Интеграционное тестирование (Integration Testing):
Тестирование взаимодействия между модулями или компонентами.
Цель: выявить проблемы, которые могут возникнуть при взаимодействии компонентов.

Функциональное тестирование (Functional Testing):
Проверка функциональности приложения в соответствии с требованиями.
Фокусируется на том, что система делает.

Системное тестирование (System Testing):
	Комплексное тестирование всей системы целиком.
	Цель: убедиться, что приложение соответствует всем заявленным требованиям и спецификациям.

Приёмочное тестирование (Acceptance Testing):
	Тестирование, проводимое для подтверждения того, что система удовлетворяет потребности пользователя.
	Включает альфа- и бета-тестирование.

Регрессионное тестирование (Regression Testing):
	Повторное тестирование системы для проверки, что изменения в коде не вызвали новых дефектов.
	Обычно проводится после внесения исправлений или новых функций.

Нагрузочное тестирование (Load Testing):
Тестирование производительности системы под различными уровнями нагрузки.
Цель: определить, как система работает при увеличении числа пользователей или объема данных.

Стресс-тестирование (Stress Testing):
Тестирование системы под экстремальными условиями, превышающими нормальные рабочие нагрузки.
Цель: выявить пределы прочности и стабильности системы.

Тестирование производительности (Performance Testing):
Оценка быстродействия системы в различных условиях.
Включает измерение времени отклика, пропускной способности и использования ресурсов.

Тестирование безопасности (Security Testing):
Проверка системы на уязвимости и угрозы безопасности.
Цель: защитить данные и обеспечить безопасную работу системы.

Тестирование удобства использования (Usability Testing):
Оценка удобства и интуитивности интерфейса для конечных пользователей.
Включает сбор отзывов пользователей и наблюдение за их взаимодействием с системой.

Тестирование совместимости (Compatibility Testing):
Проверка работы приложения на различных платформах, устройствах и браузерах.
Цель: убедиться, что система работает корректно в различных средах.

Тестирование восстановления (Recovery Testing):
Оценка способности системы восстанавливаться после сбоев и отказов.
Цель: убедиться, что система может восстановиться и продолжить работу после критических ошибок.

Тестирование локализации (Localization Testing):
Проверка адаптации приложения для различных регионов и языков.
Включает проверку правильности перевода, форматов даты и времени, валют и других региональных особенностей.
</details>

<details>
<summary>Иные вопросы</summary>

REST - архитектурный стиль. Любой формат (JSON, XNL etc)
SOAP - протокол обмена структурированными данными. Протокол (SOAP XML)


Чем отличаются протоколы http1.1 от http2.0 ?

Что такое треды операционной системы?

CORS - служит для того, чтобы например регуоировать общение браузера с апишками через AJAX запрос
</details>

C чем работал: